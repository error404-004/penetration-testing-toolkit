"""
Module: vulnerability_scanner
Description: Performs vulnerability scanning with NVD (CPE/CVEs), service fingerprinting,
multi-host scanning, and reporting.

Legal Disclaimer: Ensure you have explicit permission to scan targets. Unauthorized scanning
may violate laws or terms of service. Use responsibly and comply with NVD API policies
(https://nvd.nist.gov/developers/vulnerabilities).
"""

import json
import os
from concurrent.futures import ThreadPoolExecutor, as_completed
import socket
import argparse
import logging
import time
import requests
import ipaddress

# Use python-nmap for service detection if installed
try:
    import nmap
except ImportError:
    nmap = None

from logger import logger


class VulnerabilityScanner:
    """
    Scanner integrating with NVD for CPE-based CVE lookups and service fingerprinting.
    Supports multi-target scanning and reporting.
    """

    def __init__(self, cvss_threshold=0.0, max_results=200):
        """
        Initialize the VulnerabilityScanner.

        :param cvss_threshold: Minimum CVSS score to include CVEs (default: 0.0).
        :param max_results: Maximum number of CVEs to fetch per query (default: 200).
        """
        self.cvss_threshold = cvss_threshold
        self.max_results = max_results

    def query_nvd(self, cpe=None, keyword=None):
        """
        Query NVD API by CPE or keyword. Returns list of CVE entries.

        :param cpe: CPE string for precise lookup (e.g., 'cpe:2.3:a:apache:http_server:2.4.18').
        :param keyword: Keyword for general search (e.g., 'Apache 2.4.18').
        :return: List of CVE entries from NVD.
        """
        base_url = "https://services.nvd.nist.gov/rest/json/cves/2.0"
        params = {"resultsPerPage": self.max_results}
        if cpe:
            params["cpeName"] = cpe
        if keyword:
            params["keywordSearch"] = keyword

        # Implement retries for transient errors
        retries = 3
        delay = 5  # Seconds between retries
        for attempt in range(retries):
            try:
                logger.info(f"Querying NVD with params: {params}")
                resp = requests.get(
                    base_url,
                    params=params,
                    headers={"Accept": "application/json"},
                    timeout=15,
                )
                resp.raise_for_status()
                data = resp.json()
                # Add delay to mitigate rate limiting
                time.sleep(0.5)
                return data.get("vulnerabilities", [])
            except requests.RequestException as e:
                logger.warning(f"NVD API request failed (attempt {attempt + 1}/{retries}): {e}")
                if attempt < retries - 1:
                    time.sleep(delay)
                continue
            except json.JSONDecodeError as e:
                logger.error(f"Failed to parse NVD response JSON: {e}")
                return []
        logger.error("Failed to query NVD after retries")
        return []

    def filter_cves(self, cve_items):
        """
        Filter CVEs by CVSS threshold and sort by score. Returns list of CVE dictionaries.

        :param cve_items: List of CVE entries from NVD API.
        :return: Sorted list of CVE dictionaries with id, description, score, and severity.
        """
        filtered = []
        for item in cve_items:
            cve = item.get("cve")
            if not cve:
                continue
            score = 0.0
            severity = "N/A"
            metrics = cve.get("metrics", {})
            # Prioritize CVSS v3.1
            if "cvssMetricV31" in metrics:
                try:
                    cvss_data = metrics["cvssMetricV31"][0]["cvssData"]
                    score = cvss_data.get("baseScore", 0.0)
                    severity = cvss_data.get("baseSeverity", "N/A")
                except (IndexError, KeyError):
                    pass
            # Fallback to CVSS v3
            elif "cvssMetricV3" in metrics:
                try:
                    cvss_data = metrics["cvssMetricV3"][0]["cvssData"]
                    score = cvss_data.get("baseScore", 0.0)
                    severity = cvss_data.get("baseSeverity", "N/A")
                except (IndexError, KeyError):
                    pass
            # Fallback to CVSS v2
            elif "cvssMetricV2" in metrics:
                try:
                    cvss_data = metrics["cvssMetricV2"][0]["cvssData"]
                    score = cvss_data.get("baseScore", 0.0)
                    severity = cvss_data.get("baseSeverity", "N/A")
                except (IndexError, KeyError):
                    pass
            if score >= self.cvss_threshold:
                filtered.append({
                    "cve_id": cve.get("id"),
                    "description": cve.get("descriptions", [{}])[0].get("value", "No description"),
                    "cvss_score": score,
                    "cvss_severity": severity,
                    "published": cve.get("published", ""),
                })
        # Sort by CVSS score (descending) and publication date (descending)
        filtered.sort(key=lambda x: (x["cvss_score"], x["published"]), reverse=True)
        return filtered

    def fingerprint_services(self, target):
        """
        Use nmap to detect services and versions. Returns list of (port, name, product, version, cpe).

        :param target: IP or hostname to scan.
        :return: List of tuples containing port, service name, product, version, and CPE.
        """
        services = []
        if nmap:
            try:
                nm = nmap.PortScanner()
                # Version detection scan without ping
                nm.scan(hosts=target, arguments="-Pn -sV")
                for host in nm.all_hosts():
                    for proto in nm[host].all_protocols():
                        for port in nm[host][proto]:
                            port_data = nm[host][proto][port]
                            name = port_data.get("name")
                            product = port_data.get("product")
                            version = port_data.get("version")
                            cpes = port_data.get("cpe", [])
                            cpe = cpes[0] if cpes else None
                            services.append((str(port), name, product, version, cpe))
            except Exception as e:
                logger.error(f"Nmap scanning failed for {target}: {e}")
        else:
            logger.warning("python-nmap not installed; skipping nmap fingerprinting")
        return services

    def grab_banner(self, target, ports=None):
        """
        Perform banner grabbing on specified ports. Returns list of (port, banner) tuples.

        :param target: IP or hostname to scan.
        :param ports: List of ports to scan (default: common ports).
        :return: List of (port, banner) tuples for open ports with banners.
        """
        common_ports = ports or [80, 443, 22, 21, 25, 110, 143]
        banners = []
        for port in common_ports:
            try:
                with socket.create_connection((target, port), timeout=3) as sock:
                    try:
                        banner = sock.recv(1024).decode(errors="ignore").strip()
                    except Exception:
                        banner = ""
                    if banner:
                        logger.info(f"Banner from {target}:{port}: {banner}")
                        banners.append((str(port), banner))
            except (socket.timeout, ConnectionRefusedError, OSError):
                continue
            except Exception as e:
                logger.error(f"Error grabbing banner from {target}:{port}: {e}")
        return banners

    def scan_target(self, target):
        """
        Scan a single target for vulnerabilities. Returns dict with target and CVEs.

        :param target: IP or hostname to scan.
        :return: Dictionary with target and list of vulnerabilities.
        """
        logger.info(f"Starting scan for {target}")
        services = self.fingerprint_services(target)
        # Enhance with banner grabbing for incomplete services
        additional_ports = []
        for port, name, product, version, cpe in services:
            if name == "unknown" or not product:
                additional_ports.append(int(port))
        if additional_ports or not services:
            logger.info(f"Attempting banner grabbing for {target} on ports {additional_ports or 'common'}")
            banners = self.grab_banner(target, ports=additional_ports or None)
            # Add banner-based services, avoiding duplicates
            existing_ports = {port for port, _, _, _, _ in services}
            for port, banner in banners:
                if port not in existing_ports:
                    services.append((port, None, banner, None, None))

        all_vulns = []
        for service in services:
            port, name, product, version, cpe = service
            cve_items = []
            if cpe:
                logger.info(f"Querying NVD with CPE: {cpe}")
                cve_items = self.query_nvd(cpe=cpe)
            else:
                # Construct keyword from available data
                keyword = product or name or ""
                if version:
                    keyword = f"{keyword} {version}".strip()
                if keyword:
                    logger.info(f"Querying NVD with keyword: {keyword}")
                    cve_items = self.query_nvd(keyword=keyword)
            vulns = self.filter_cves(cve_items)
            logger.info(f"Found {len(vulns)} CVEs for service {product or name or 'N/A'} on port {port}")
            for v in vulns:
                v["service"] = product or name or "N/A"
                v["port"] = port
                all_vulns.append(v)
        return {"target": target, "vulnerabilities": all_vulns}

    def scan(self, targets, output_file=None, html_summary=False):
        """
        Scan multiple targets in parallel. Optionally write JSON report and HTML summary.

        :param targets: List of IP addresses or hostnames.
        :param output_file: Path to save JSON report (optional).
        :param html_summary: Generate HTML summary if True (requires report_generator).
        :return: List of result dictionaries.
        """
        results = []
        max_workers = min(10, len(targets)) or 1
        with ThreadPoolExecutor(max_workers=max_workers) as executor:
            futures = {executor.submit(self.scan_target, t): t for t in targets}
            for future in as_completed(futures):
                target = futures[future]
                try:
                    res = future.result()
                    results.append(res)
                except Exception as e:
                    logger.error(f"Error scanning {target}: {e}")
        # Write JSON report
        if output_file:
            try:
                with open(output_file, "w", encoding="utf-8") as f:
                    json.dump(results, f, indent=2)
                logger.info(f"Saved JSON report to {output_file}")
            except Exception as e:
                logger.error(f"Failed to write report file: {e}")
        # Generate HTML summary
        if html_summary:
            try:
                from . import report_generator
                report_generator.generate_report(results)
                logger.info("Generated HTML summary report")
            except ImportError:
                logger.warning("Report generator not found; skipping HTML summary")
            except Exception as e:
                logger.error(f"HTML summary generation failed: {e}")
        return results


def parse_targets(targets_arg):
    """
    Parse --targets argument into a list of valid targets. Supports IPv4 and IPv6.

    :param targets_arg: Comma-separated targets or file path.
    :return: List of valid target strings.
    """
    targets = []
    if os.path.isfile(targets_arg):
        try:
            with open(targets_arg, encoding="utf-8") as f:
                targets = [line.strip() for line in f if line.strip()]
        except Exception as e:
            logger.error(f"Failed to read targets file {targets_arg}: {e}")
            return []
    else:
        targets = [t.strip() for t in targets_arg.split(",") if t.strip()]

    # Validate targets
    valid_targets = []
    for target in targets:
        try:
            # Try IP address (IPv4 or IPv6)
            ipaddress.ip_address(target)
            valid_targets.append(target)
        except ValueError:
            # Try hostname resolution
            try:
                socket.gethostbyname(target)
                valid_targets.append(target)
            except socket.gaierror:
                logger.warning(f"Invalid target: {target}")
    return valid_targets


def main():
    """
    Command-line interface for the vulnerability scanner.
    """
    parser = argparse.ArgumentParser(description="Vulnerability Scanner with NVD Integration")
    parser.add_argument(
        "--targets",
        required=True,
        help="Target IP(s)/domain(s), comma-separated or file path",
    )
    parser.add_argument(
        "--cvss-threshold",
        type=float,
        default=0.0,
        help="CVSS score threshold to filter CVEs",
    )
    parser.add_argument(
        "--export-report",
        help="File path to export JSON report",
    )
    parser.add_argument(
        "--html-summary",
        action="store_true",
        help="Generate HTML report summary if report_generator is available",
    )
    args = parser.parse_args()

    targets = parse_targets(args.targets)
    if not targets:
        logger.error("No valid targets provided.")
        print("No valid targets provided. Please specify valid targets via --targets.")
        return

    print(f"[+] Scanning {len(targets)} target(s)...")
    scanner = VulnerabilityScanner(cvss_threshold=args.cvss_threshold)
    results = scanner.scan(
        targets,
        output_file=args.export_report,
        html_summary=args.html_summary,
    )

    # Print console summary
    for result in results:
        target = result.get("target")
        vulns = result.get("vulnerabilities", [])
        print(f"\nTarget: {target}")
        if vulns:
            print(f"  Vulnerabilities found: {len(vulns)}")
            for v in vulns:
                print(
                    f"    - {v['cve_id']} (Score: {v['cvss_score']}, "
                    f"Severity: {v['cvss_severity']})"
                )
                print(f"      Description: {v['description']}")
                print(f"      Service: {v.get('service', 'N/A')}")
                print(f"      Port: {v.get('port', 'N/A')}")
        else:
            print("  No vulnerabilities found.")


if __name__ == "__main__":
    main()